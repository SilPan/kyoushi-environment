filter {
  if [type] == "syslog" or [type] == "auth" {

    mutate {
        # remove manually set hostname so that we dont end up with a list
        # since auth and syslog groks will set the hostname
        remove_field => "[host][hostname]"
    }
    if [type] == "auth" {
      
      mutate {
        add_field => { 
          "[event][category]" => "auth"
        }
      }

      grok {
        # parse auth logs
        match => { 
                  "message" => [
                    "%{SYSLOGBASE3} sshd(?:\[%{POSINT:[system][auth][pid]}\])?: %{DATA:[system][auth][ssh][event]} %{DATA:[system][auth][ssh][method]} for (invalid user )?%{DATA:[system][auth][user]} from %{IPORHOST:[system][auth][ssh][ip]} port %{NUMBER:[system][auth][ssh][port]} ssh2(: %{GREEDYDATA:[system][auth][ssh][signature]})?",
                    "%{SYSLOGBASE3} sshd(?:\[%{POSINT:[system][auth][pid]}\])?: %{DATA:[system][auth][ssh][event]} user %{DATA:[system][auth][user]} from %{IPORHOST:[system][auth][ssh][ip]}",
                    "%{SYSLOGBASE3} sshd(?:\[%{POSINT:[system][auth][pid]}\])?: Did not receive identification string from %{IPORHOST:[system][auth][ssh][dropped_ip]}",
                    "%{SYSLOGBASE3} sudo(?:\[%{POSINT:[system][auth][pid]}\])?: \s*%{DATA:[system][auth][user]} :( %{DATA:[system][auth][sudo][error]} ;)? TTY=%{DATA:[system][auth][sudo][tty]} ; PWD=%{DATA:[system][auth][sudo][pwd]} ; USER=%{DATA:[system][auth][sudo][user]} ; COMMAND=%{GREEDYDATA:[system][auth][sudo][command]}",
                    "%{SYSLOGPAMSESSION}",
                    "%{SYSLOGBASE3} groupadd(?:\[%{POSINT:[system][auth][pid]}\])?: new group: name=%{DATA:[system][auth][groupadd][name]}, GID=%{NUMBER:[system][auth][groupadd][gid]}",
                    "%{SYSLOGBASE3} useradd(?:\[%{POSINT:[system][auth][pid]}\])?: new user: name=%{DATA:[system][auth][useradd][name]}, UID=%{NUMBER:[system][auth][useradd][uid]}, GID=%{NUMBER:[system][auth][useradd][gid]}, home=%{DATA:[system][auth][useradd][home]}, shell=%{DATA:[system][auth][useradd][shell]}$",
                    "%{SYSLOGBASE3} %{DATA:[system][auth][program]}(?:\[%{POSINT:[system][auth][pid]}\])?: %{GREEDYMULTILINE:[system][auth][message]}"
                  ] 
                }
        pattern_definitions => {
          "GREEDYMULTILINE"=> "(.|\n)*"
          "SYSLOGBASE3" => "(?:%{SYSLOGTIMESTAMP:timestamp}|%{TIMESTAMP_ISO8601:timestamp})(?: %{SYSLOGFACILITY})?(?: %{SYSLOGHOST:[host][hostname]})?"
        }
        remove_field => "message"
      }
    } else if [type] == "syslog" {

      mutate {
        add_field => { 
          "[event][category]" => "syslog"
        }
      }

      # parse syslog messages
      grok {
        match => { "message" => [
                "%{CRONLOG}",
                "%{SYSLOGLINE}"
            ] 
        }
        overwrite => [ "message" ]
      }
    }
    if [system][cron] {
      mutate {
        add_field => { "[event][action]" => "cron" }
      }
    }

    ruby {
        # manually add the year since syslog/auth.log 
        # do not include this information
        # this is a simple approach and will break if dataset crosses
        # year boundary
        code => '
            year = @@observe_start.time.strftime("%Y")
            event.set("timestamp",  year+" "+event.get("timestamp"))
        '
    }

    date {
        match => [ "timestamp", "yyyy MMM  d HH:mm:ss", "yyyy MMM dd HH:mm:ss" ]
        remove_field => "timestamp"
        timezone => "%{[@metadata][event][timezone]}"
    }
  }
}